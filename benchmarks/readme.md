# pyriccaticpp benchmarks

## Running Benchmarks

Run the following from the top level folder to create the timing and performance output files:

```bash
# Only run these two lines if you do not already have a virtual environment
python -m venv ./.venv
source ./.venv/bin/activate
# Install dependencies
pip install -r ./requirements.txt
pip install .
# Run benchmarks
python3 ./benchmarks/schrodinger_eq.py
python3 ./benchmarks/solve_ivp_bench.py
```

This will generate the CSV output for each solver and problem under `./benchmarks/output/`.
The plots can be generated by calling

```bash
Rscript ./benchmarks/plot_ivp_bench.R
Rscript ./benchmarks/plot_schrodinger.R
```

## Solve IVP Results

### Equations and Setup

We consider three ODE problems for direct time-domain integration with `solve_ivp` or `pyriccaticpp`:

1. **Bremer eq. 237**

Our first example is taken from Bremer (2018), Eq. (237) for $x \in [-1,\,1]$:

```math
       y''(x) + \lambda^2\bigl[1 - x^2 \cos(3x)\bigr]\,y(x) \;=\; 0,
```

with initial conditions

```math
     y(-1) = 0,
     \quad
     y'(-1) = \lambda,
```

so that the problem depends strongly on $\lambda$. As $\lambda$ grows, the equation becomes increasingly oscillatory (high-frequency), which is challenging for general-purpose ODE solvers.

2. **Airy equation**

   The Airy equation, used in optics, is an oscillator if the dependent variable is transformed as $x \to -x$, yielding 

```math
       y''(x) - x \, y(x) \;=\; 0,
```

for $x \in [0,\,100]$. The Airy functions $\mathrm{Ai}$ and $\mathrm{Bi}$ form a basis for the solution space. We pose initial conditions 
```math
       y'(x) = \begin{bmatrix} y_1'(x) \\ y_2'(x) \end{bmatrix}
               = \begin{bmatrix}
                   y_2(x) \\
                   -\,x\,y_1(x)
                 \end{bmatrix}.
```

3. **Stiff problem**

Stiffness is notoriously difficult to define, but all stiff problems have the common property that explicit solvers do not perform well on them. The following equation is stiff because there are two extremely different timescales present in the solution; explicit integrators are forced to follow the faster timescale (take smaller steps), even though this component of the solution is exponentially small. Vastly different scales arise in many multi-physics problems, and this example illustrates that `pyriccaticpp` will not perform worse than the implicit methods available in `scipy.solve_ivp` on this category of equations. We solve 

```math
       y''(x) \;+\; (x + 21)\,y'(x) \;+\; 21\,x\,y(x) \;=\; 0.
```

on  $[0,\,200]$ with initial conditions

```math
       y(0) = 0,
       \quad
       y'(0) = 1.
```

In each case, we compare the runtime and accuracy of the following solvers (the first three being method options in `scipy.solve_ivp`):

- **BDF**: An implicit solver formulated for stiff equations.
- **DOP853**: An explicit Runge–Kutta method of order 8(5,3).
- **RK45**: An explicit Runge–Kutta 4(5) method.
- **PYRICCATICPP**: Our specialized solver for second-order (oscillatory) ODEs.

Note that both runtimes and accuracies are plotted on a logarithmic scale.

## Timing Results

The figures below (`ivp_bench.png`) show the average runtime (in seconds, averaged over $10$ solves) each solver takes for the Bremer, Airy, and Stiff equations across two different tolerances ($10^{-12}$ and $10^{-6}$). As the solution becomes more oscillatory ($\lambda$ increases), the runtime of standard polynomial-based solvers (Runge--Kutta and BDF) grows linearly ($\mathcal{O}(\lambda)$), whereas that of `pyriccaticpp` remains constant ($\mathcal{O}(1)$). On the stiff problem, `pyriccaticpp` outperforms `BDF` at the tighter tolerance and is comparative at the looser tolerance, with all explicit solvers being significantly slower, as expected. 

- **Bremer (Eq. 237)**:

  The table below shows `wall time method / wall time pyriccaticpp` for each $\lambda$ value of the Bremer equation benchmarked. The highlighted values in each row show the relative runtime of the second fastest method relative to pyriccaticpp. Even in the most favorable scenario for the classical methods (the smallest $\lambda = 10$) DOP853 is still 4.7$\times$ slower than pyriccaticpp; for large $\lambda$, the classical solvers are orders of magnitude slower.

** Steve: Which tolerance is this for? **  
** TODO for Fruzsina: add note about accuracy of BDF -- it looks deceivingly fast here, but it produces garbage **

### Table For Bremer Eq 237 Relative Wall Time To Pyriccaticpp

| lambda|      BDF|      DOP853|        RK45|
|------:|--------:|-----------:|-----------:|
|  1e+01|    58.81|        **3.91**|       26.66|
|  1e+02| 17299.58|     **1172.55**|     8977.71|
|  1e+03|   **551.49**|    13632.90|   104830.64|
|  1e+04|   **600.00**|   143353.08|  1108936.18|
|  1e+05|    **12.04**|  1447427.56| 11306510.13|
|  1e+06|     **6.56**| 10962325.93| 10962325.93|
|  1e+07|     **5.49**| 11138993.87| 11138993.87|


- **Airy**:
 At the end of the solution interval, $x = 100$, the characteristic frequency of oscillations in the solution of the Airy equation is $\sqrt{x} = 10$. The specialized approach in `pyriccaticpp` is, in the most competitive case when the relative error is `1e-6`, 37 times faster than its closest competitor, `DOP853`. If the solution is continued to larger values of $x$, this gap further grows, since the Airy solution gets progressively more oscillatory.

- **Stiff**:
  While `BDF` is able to compete with `pyriccaticpp` for a relative tolerance of `1e-6`, when asking for a relative tolerance of `1e-12` the graph shows that `pyriccaticpp` is 3 orders of magnitude faster than `BDF`.

[Talk about solve_ivp benchmark results here]
** Steve: what does this above note mean? **

![ivp_bench](/benchmarks/plots/ivp_bench.png)

## Relative Error Results

The figure below (`ivp_bench_errs.png`) plots the relative error of the solution at the end of the solution interval for each method against a reference value, computed to high accuracy via ** TODO: how is it computed? ** . We highlight the following:

- **Bremer**: With smaller $\lambda$, all methods achieve a global accuracy consistent with the user-defined local tolerance. At large $\lambda$, we note that the large condition number of the problem does not allow for a global accuracy of $10^{-12}$ to be achieved. ** TODO: Fruzsina to insert citation here re condition number. ** `pyriccaticpp` produces the smallest error that one could realistically expect for a problem with this condition number (and working in double precision arithmetic). Classical methods are forced to take more and smaller steps, which accummulates local error, resulting in a global error that is a few orders of magnitue larger than the tolerance setting, except for BDF, which fails catastrophically and produces $\mathcal{O}(1)$ error. ** TODO: may need to change this after Steve's check. ** 
- **Airy**: Most standard solvers maintain good accuracy here. The specialized approach also works very well, typically matching or outperforming BDF and DOP853.
- **Stiff**: All methods can reach very low errors if allowed a sufficiently tight tolerance. However, once again, `pyriccaticpp` can achieve extremely small relative error in the same or less time than standard solvers, illustrating its suitability for stiff or high-frequency problems alike.
![ivp_bench_err](/benchmarks/plots/ivp_bench_errs.png)

## Schrödinger Equation

### Problem Setup

In the Schrödinger equation benchmark, we consider a one-dimensional potential

```math
   V(x) \;=\; x^2 \;+\; l\,x^4,
```

with some mass parameter $m$ (here $m=0.5$), seeking the bound-state energies for large quantum numbers. We do so by implementing a **shooting method**:

1. We define the ODE which is a form of the time-independent Schrödinger equation.

```math
       \psi''(x) \;=\; -\,2m\;\bigl[E - V(x)\bigr]\;\psi(x),
```

2. For each guess $E$ of the energy, we integrate from a left boundary to the midpoint and from a right boundary to the midpoint.

3. We then minimize the mismatch in derivatives at the midpoint to find an accurate bound-state energy.

We compare the same four solvers `BDF`, `DOP853`, `RK45`, and `pyriccaticpp`. But in this scenario each integration is part of a root-finding (optimization) loop.

### Timing Results

Below (`schrodinger.png`) we plot the average time spent in these ODE solves for each method, combined over different quantum numbers (roughly corresponding to the energy range). Two relative tolerances were used, $10^{-12}$ (high precision) and $10^{-6}$ (moderate precision).

- As the quantum number grows, the wavefunction oscillates more in the classically allowed region, much like the high-frequency case in the Bremer problem. Standard ODE solvers require more steps or smaller steps.
- `pyriccaticpp` retains consistently low wall-time for large quantum numbers, indicating it handles rapidly oscillatory wavefunctions efficiently.
-

![sch_bench_err_qn](/benchmarks/plots/schrodinger_energy.png)
![sch_bench_err](/benchmarks/plots/schrodinger.png)

### Timing Relative to pyriccaticpp for Schrodinger's Equation for Relative Error 1e-6

|quantum_number |BDF    |DOP853 |RK45   |
|:--------------|:------|:------|:------|
|50             |18.94  |**1.660**  |4.940  |
|100            |26.34  |**2.260**  |7.024  |
|1000           |78.51  |**6.708**  |21.901 |
|10000          |237.36 |**20.145** |66.802 |

Each value can be interpreted as "In the Schrodinger benchmark, pyriccaticpp is `x` times faster than {method}."

### Relative Error Results

The figure below (`schrodinger_err.png`) shows the relative error in the computed energy level compared to [1](http://doi.org/10.1098/rspa.1978.0086). All methods are capable of producing accurate energy eigenvalues given a tight enough tolerance.

![sch_bench_err](/benchmarks/plots/schrodinger_err.png)

## Summary

Overall, the **Riccati-based** solver (`pyriccaticpp`) offers a substantial speed-up and robust accuracy, particularly in problems where the solution has large oscillations or stiff behavior.

[1] Banerjee K. , Bhatnagar S. P. , Choudhry V. and Kanwal S. S. 1978The anharmonic oscillatorProc. R. Soc. Lond. A360575–586
http://doi.org/10.1098/rspa.1978.0086
