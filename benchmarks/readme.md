# pyriccaticpp benchmarks

## Running Benchmarks

Runrun the following from the top level folder to create the timing and performance output files

```bash
# Only run these two lines if you do not already have a virtual environment
python -m venv ./.venv
source ./.venv/bin/activate
# Install dependencies
pip install -r ./requirements.txt
pip install .
# Run benchmarks
python3 ./benchmarks/schrodinger_eq.py
python3 ./benchmarks/solve_ivp_bench.py
```

This will generate the CSV output for each solver and problem under `./benchmarks/output/`.
The plots can be generated by calling

```bash
Rscript ./benchmarks/plot_ivp_bench.R
Rscript ./benchmarks/plot_schrodinger.R
```

## Solve IVP Results

### Equations and Setup

We consider three ODE problems for direct time-domain integration with `solve_ivp` or `pyriccaticpp`:

1. **Bremer Eq. 237**
   Taken from Bremer (2018), Eq. (237).
```math
       y''(x) + \lambda^2\bigl[1 - x^2 \cos(3x)\bigr]\,y(x) \;=\; 0,
```
   for $x \in [-1,\,1]$. The initial conditions are chosen as
```math
     y(-1) = 0,
     \quad
     y'(-1) = \lambda,
```
   so that the problem depends strongly on $\lambda$. As $\lambda$ grows, the equation becomes increasingly oscillatory (high-frequency), which can be challenging for general-purpose ODE solvers.

2. **Airy Equation**
   The classical Airy equation can be written as
```math
       y''(x) - x \, y(x) \;=\; 0,
```
   for $x \in [0,\,100]$. The Airy functions $\mathrm{Ai}$ and $\mathrm{Bi}$ form the fundamental solutions; however, here we pose initial conditions in terms of these functions at $x = 0$ and integrate out to $x = 100$. Numerically, one can write this as
```math
       y'(x) = \begin{bmatrix} y_1'(x) \\ y_2'(x) \end{bmatrix}
               = \begin{bmatrix}
                   y_2(x) \\
                   -\,x\,y_1(x)
                 \end{bmatrix}.
```

3. **Stiff Problem**
   We label this “Stiff” because it includes large and rapidly changing coefficients. The equation is
```math
       y''(t) \;+\; (t + 21)\,y'(t) \;+\; 21\,t\,y(t) \;=\; 0,
```
   integrated on $[0,\,200]$ with initial conditions
```math
       y(0) = 0,
       \quad
       y'(0) = 1.
```
   The combination of the $t\,y'(t)$ and $t\,y(t)$ terms can produce stiffness as $t$ grows large.

In each case, we compare several solvers:

- **BDF**: A stiff, implicit solver.
- **DOP853**: An explicit Runge–Kutta method of order 8(5,3).
- **RK45**: A classic explicit Runge–Kutta 4(5) method.
- **PYRICCATICPP**: Our specialized solver using a Riccati transform for second-order ODEs.

Times for each graph below are on a logarithmic scale to accommodate the rapid growth in runtime for certain methods at higher frequencies or stiffer regimes.

## Timing Results

Below is a representative plot (`ivp_bench.png`) of the average runtime (in seconds) each solver takes for the Bremer, Airy, and Stiff equations across two different tolerances ($10^{-12}$ and $10^{-6}$). As $\lambda$ or problem stiffness increases, one observes that standard Runge–Kutta-based solvers can become extremely slow, whereas `pyriccaticpp` remains comparatively fast.

- **Bremer (Eq. 237)**:
  For $\lambda = 10$, the ODE solver times are the closest, but `pyriccaticpp` is still faster than all others by more than 4 orders of magnitude. As $\lambda$ increases to $10^4, 10^5, 10^6$, `pyriccaticpp` retains a very low wall time, while `BDF`, `RK45`, and `DOP853` grow by orders of magnitude.

  The table below shows `wall time method / wall time pyriccaticpp` for each lambda value of the Bremer equation benchmarked. The highlighted values in each row show the fastest method relative to pyriccaticpp. Even in the most favorable scenario for the classical methods (the smallest $\lambda = 10$) DOP853 is still 4.7× slower than pyriccaticpp; for large $\lambda$, the classical solvers are orders of magnitude slower.

### Table For Bremer Eq 237 Relative Wall Time To Pyriccaticpp

| lambda|      BDF|      DOP853|        RK45|
|------:|--------:|-----------:|-----------:|
|  1e+01|    70.76|        **4.71**|       33.28|
|  1e+02| 17436.49|     **1171.46**|     9351.31|
|  1e+03|   **567.63**|    13937.79|   110215.06|
|  1e+04|   **605.13**|   144860.11|  1154850.08|
|  1e+05|    **12.38**|  1429484.20| 11544491.11|
|  1e+06|     **7.21**| 11764395.45| 11764395.45|
|  1e+07|     **6.01**| 12217426.15| 12217426.15|


- **Airy**:
  The Airy benchmark is integrated out to a relatively large domain $[0,100]$. The specialized approach in `pyriccaticpp` is, in the most competitive case when the relative error is `1e-6`, 37 times faster than it's closest competitor `DOP853`.

- **Stiff**:
  As the name suggests, the presence of a rapidly varying coefficient makes this ODE a good test of stiff integrators. While `BDF` is able to compete with `pyriccaticpp` for a relative tolerance of `1e-6`, when asking for a relative tolerance of `1e-12` the graph shows that `pyriccaticpp` is 3 orders of magnitude faster than `BDF`.


[Talk about solve_ivp benchmark results here]

![ivp_bench](/benchmarks/plots/ivp_bench.png)


## Relative Error Results

Below is a plot (`ivp_bench_errs.png`) illustrating the relative error of the final solution for each method against a reference “high-precision” solution. We highlight the following:

- **Bremer**: With smaller $\lambda$, all methods achieve very good accuracy. At large $\lambda$, some methods degrade or appear to clamp at an error near $10^{-3}$ for the less stringent tolerance setting. `pyriccaticpp` generally holds a very small error even as $\lambda$ increases.
- **Airy**: Most standard solvers maintain good accuracy here. The specialized approach also works very well, typically matching or outperforming BDF and DOP853.
- **Stiff**: All methods can reach very low errors if allowed a sufficiently tight tolerance. However, once again, `pyriccaticpp` can achieve extremely small relative error in the same or less time than standard solvers, illustrating its suitability for stiff or high-frequency problems alike.
![ivp_bench_err](/benchmarks/plots/ivp_bench_errs.png)

## Schrödinger Equation

### Problem Setup

In the Schrödinger equation benchmark, we consider a one-dimensional potential
```math
   V(x) \;=\; x^2 \;+\; l\,x^4,
```
with some mass parameter $m$ (here $m=0.5$), seeking the bound-state energies for large quantum numbers. We do so by implementing a **shooting method**:

1. We define the ODE
```math
       \psi''(x) \;=\; -\,2m\;\bigl[E - V(x)\bigr]\;\psi(x),
```
   which is a form of the time-independent Schrödinger equation.
2. For each guess $E$ of the energy, we integrate from a left boundary to the midpoint and from a right boundary to the midpoint.
3. We then minimize the mismatch in derivatives at the midpoint to find an accurate bound-state energy.

We compare the same four solvers `BDF`, `DOP853`, `RK45`, and `pyriccaticpp`. But in this scenario each integration is part of a root-finding (optimization) loop.

### Timing Results

Below (`schrodinger.png`) we plot the average time spent in these ODE solves for each method, combined over different quantum numbers (roughly corresponding to the energy range). Two relative tolerances were used, $10^{-12}$ (high precision) and $10^{-6}$ (moderate precision).

- As the quantum number grows, the wavefunction oscillates more in the classically allowed region, much like the high-frequency case in the Bremer problem. Standard ODE solvers require more steps or smaller steps.
- `pyriccaticpp` retains consistently low wall-time for large quantum numbers, indicating it handles rapidly oscillatory wavefunctions efficiently.
-

![sch_bench_err_qn](/benchmarks/plots/schrodinger_energy.png)
![sch_bench_err](/benchmarks/plots/schrodinger.png)

### Timing Relative to pyriccaticpp for Schrodinger's Equation for Relative Error 1e-6

|quantum_number |BDF   |DOP853 |RK45  |
|:--------------|:-----|:------|:-----|
|50             |18.73 |2.019  |5.165 |
|100            |19.47 |2.181  |5.581 |
|1000           |16.11 |1.980  |4.920 |
|10000          |14.00 |1.858  |4.451 |

### Relative Error Results

The figure below (`schrodinger_err.png`) shows the relative error in the computed energy level compared to [1](http://doi.org/10.1098/rspa.1978.0086). All methods are capable of producing accurate energy eigenvalues given a tight enough tolerance.


![sch_bench_err](/benchmarks/plots/schrodinger_err.png)


## Summary

Overall, the **Riccati-based** solver (`pyriccaticpp`) offers a substantial speed-up and robust accuracy, particularly in problems where the solution has large oscillations or stiff behavior.

[1] Banerjee K. , Bhatnagar S. P. , Choudhry V. and Kanwal S. S. 1978The anharmonic oscillatorProc. R. Soc. Lond. A360575–586
http://doi.org/10.1098/rspa.1978.0086
