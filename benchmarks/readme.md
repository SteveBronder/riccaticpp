# pyriccaticpp benchmarks

## Running Benchmarks

Run the following from the top level folder to create the timing and performance output files:

```bash
# Only run these two lines if you do not already have a virtual environment
python -m venv ./.venv
source ./.venv/bin/activate
# Install dependencies
pip install -r ./requirements.txt
pip install .
# Run benchmarks
python3 ./benchmarks/schrodinger_eq.py
python3 ./benchmarks/solve_ivp_bench.py
```

This will generate the CSV output for each solver and problem under `./benchmarks/output/`.
The plots can be generated by calling

```bash
Rscript ./benchmarks/plot_ivp_bench.R
Rscript ./benchmarks/plot_schrodinger.R
```

## Solve IVP Results

### Equations and Setup

We consider three ODE problems for direct time-domain integration with `solve_ivp` or `pyriccaticpp`:

1. **Bremer eq. 237**

Our first example is taken from Bremer (2018), Eq. (237) for $x \in [-1,\,1]$:

```math
       y''(x) + \lambda^2\bigl[1 - x^2 \cos(3x)\bigr]\,y(x) \;=\; 0,
```

with initial conditions

```math
     y(-1) = 0,
     \quad
     y'(-1) = \lambda,
```

so that the problem depends strongly on $\lambda$. As $\lambda$ grows, the equation becomes increasingly oscillatory (high-frequency), which is challenging for general-purpose ODE solvers.

2. **Airy equation**

   The Airy equation, used in optics, is an oscillator if the dependent variable is transformed as $x \to -x$, yielding

```math
       y''(x) - x \, y(x) \;=\; 0,
```

for $x \in [0,\,100]$. The Airy functions $\mathrm{Ai}$ and $\mathrm{Bi}$ form a basis for the solution space. We pose initial conditions
```math
       y'(x) = \begin{bmatrix} y_1'(x) \\ y_2'(x) \end{bmatrix}
               = \begin{bmatrix}
                   y_2(x) \\
                   -\,x\,y_1(x)
                 \end{bmatrix}.
```

3. **Stiff problem**

Stiffness is notoriously difficult to define, but all stiff problems have the common property that explicit solvers do not perform well on them. The following equation is stiff because there are two extremely different timescales present in the solution. Explicit integrators are forced to follow the faster timescale (take smaller steps), even though this component of the solution is exponentially small. Vastly different scales arise in many multi-physics problems, and this example illustrates that `pyriccaticpp` will not perform worse than the implicit methods available in `scipy.integrate.solve_ivp` on this category of equations. We solve

```math
       y''(x) \;+\; (x + 21)\,y'(x) \;+\; 21\,x\,y(x) \;=\; 0.
```

on  $[0,\,200]$ with initial conditions

```math
       y(0) = 0,
       \quad
       y'(0) = 1.
```

In each case, we compare the runtime and accuracy of the following solvers (the first three being method options in `scipy.integrate.solve_ivp`):

- **BDF**: An implicit solver formulated for stiff equations.
- **DOP853**: An explicit Runge–Kutta method of order 8(5,3).
- **RK45**: An explicit Runge–Kutta 4(5) method.
- **PYRICCATICPP**: Our specialized solver for second-order (oscillatory) ODEs.

Note that both runtimes and accuracies are plotted on a logarithmic scale.

## Timing Results

The figures below (`ivp_bench.png`) show the median runtime (in seconds, averaged over $20$ solves) each solver takes for the Bremer, Airy, and Stiff equations across two different tolerances ($10^{-12}$ and $10^{-6}$). For Bremer, points marked as `X` are when all 20 runs for the solver failed to find a correct answer. As the solution becomes more oscillatory ($\lambda$ increases), the runtime of standard polynomial-based solvers (Runge--Kutta and BDF) grows linearly ($\mathcal{O}(\lambda)$), whereas that of `pyriccaticpp` remains constant ($\mathcal{O}(1)$). On the stiff problem, `pyriccaticpp` outperforms `BDF` at the tighter tolerance and is comparative at the looser tolerance, with all explicit solvers being significantly slower, as expected.

- **Bremer (Eq. 237)**:

  The table below shows `wall time method / wall time pyriccaticpp` for each $\lambda$ value of the Bremer equation benchmarked.
  NA values signify that the solver completed but gave an erroneous answer.
  The highlighted values in each row show the relative runtime of the fastest method relative to pyriccaticpp.
  Even in the most favorable scenario for the classical methods (the smallest $\lambda = 10$) pyriccaticpp is still 5.23$\times$ faster than DOP853. For large $\lambda$, the classical solvers are orders of magnitude slower.

### Table For Bremer Eq 237 with eps=1e-12 Median Relative Wall Time To Pyriccaticpp

| $\lambda$|      BDF|      DOP853|        RK45|
|------:|--------:|-----------:|-----------:|
|  10|    55.70|        **5.23**|       28.00|
|  100| 17219.38|     **1155.45**|     9250.24|
|  1000|   NA|    **13678.30**|   109667.48|
|  1e+04|   NA|   **141617.52**|  1139463.41|
|  1e+05|    NA|  **1441279.23**| NA|
|  1e+06|     NA| NA| NA|
|  1e+07|     NA| NA| NA|


- **Airy**:
 At the end of the solution interval, $x = 100$, the characteristic frequency of oscillations in the solution of the Airy equation is $\sqrt{x} = 10$. The specialized approach in `pyriccaticpp` is, in the most competitive case when the relative error is `1e-6`, 30 times faster than its closest competitor, `DOP853`. If the solution is continued to larger values of $x$, this gap further grows, since the Airy solution gets progressively more oscillatory.

- **Stiff**:
  While `BDF` is able to compete with `pyriccaticpp` for a relative tolerance of `1e-6`, when asking for a relative tolerance of `1e-12` the graph shows that `pyriccaticpp` is 3 orders of magnitude faster than `BDF`.

![ivp_bench](/benchmarks/plots/ivp_bench.png)

## Relative Error Results

The figure below (`ivp_bench_errs.png`) plots the relative error of the solution at the end of the solution interval for each method against an analytic reference value (which is available for all examples). We highlight the following:

- **Bremer**: With smaller $\lambda$, all methods achieve a global accuracy consistent with the user-defined local tolerance. At large $\lambda$, we note that the large condition number of the problem does not allow for a global accuracy of $10^{-12}$ to be achieved (see section 4 of @agocs2024adaptive ). `pyriccaticpp` produces the smallest error that one could realistically expect for a problem with this condition number (and working in double precision arithmetic). Classical methods are forced to take more and smaller steps, which accummulates local error, resulting in a global error that is a few orders of magnitude larger than the tolerance setting, except for BDF, which fails catastrophically and produces $\mathcal{O}(1)$ error.
- **Airy**: Apart from the high-order `DOP853` method and `pyriccaticpp`, none produced an error within one order of magnitude of the tolerance setting, with the latter being a factor of 10 more accurate than the former.
- **Stiff**: The analytic solution at the end of the solution interval in this example zero (to more than 100 digits). Therefore, computing a relative accuracy is meaningless. we plot the _absolute_ error, computed simply as the output of the given method at the end of the solution interval, instead. Due to a strong damping term in the equation, all solvers achieve low errors, but over extremely different runtimes.

![ivp_bench_err](/benchmarks/plots/ivp_bench_errs.png)

## Schrödinger Equation

### Problem Setup

In this physically motivated benchmark, we compute the allowed energies of a particle in a one-dimensional potential. This type of problem arises in molecular physics, e.g. in the calibration of lasers. We consider an anharmonic perturbation of the harmonic potential,

```math
   V(x) \;=\; x^2 \;+\; l\,x^4,
```

with $l = 1$. The allowed energies (eigenvalues) of this potential are not known analytically. The particle has mass $m = 0.5$, and obeys the one-dimensional, time-independent Schrödinger equation,

\begin{equation}\label{eq:schrodinger}
       \psi''(x) \;=\; -\,2m\;\bigl[E - V(x)\bigr]\;\psi(x),
\end{equation}

at energy $E$.

Since $E$ is not known a priori, we compute it via a **shooting method**:

1. For the given energy level, we obtain an upper and lower bound via asymptotic approximations so that $E \in [E_{\mathrm{min}}, E_{\mathrm{max}}]$. We will search for the correct energy within this bracket.

2. For each guess $E$ of the energy, we integrate \autoref{eq:schrodinger} from a point far outside the potential well (so that $E \gg V(\pm x_0)$) on either side, $x = \pm x_0$, towards the middle of the potential well, starting from the initial cconditions $\psi(\pm x_0) = 0$, $\psi'(\pm x_0) = 1$. The two numerical solutions, $\psi_L$ and $\psi_R$, meet at an intermediate point $x_1$, where the solution and its derivative is continuous if and only if $E$ is an eigenvalue. To quantify the "mismatch", we define

$$ f(E) = \frac{\psi'_L}{\psi_L} - \frac{\psi'_R}{\psi_R}.  $$

3. We then minimize this mismatch by finding the real roots of $f(E)$. The eigenvalues $E$ are given by the roots.

We compare the same four solvers `BDF`, `DOP853`, `RK45`, and `pyriccaticpp`,in this case called within a root-finding loop.

### Timing Results

Below (`schrodinger.png`) we plot the average time spent in these ODE solves for each method, combined over different energy levels, which we index with nonnegative integer quantum numbers $n$, with $n=0$ being the ground state. Two relative tolerances were used, $10^{-12}$ and $10^{-6}$.

- As the quantum number grows, the wavefunction $\psi(x)$ oscillates more in the classically allowed region (inside the potential well), and decays exponentially outside of it. Standard ODE solvers require more and smaller steps as $n$ grows.
- `pyriccaticpp`'s runtime also scales with the quantum number, which is due to a growing number of steps taken outside of the potential well. The runtime, however, scales more gently than that of other methods, yielding a factor of $\approx 20$ speedup at the highest quantum number and moderate tolerance setting, and an $\approx 70$-fold speedup at the tight tolerance.


![sch_bench_err_qn](/benchmarks/plots/schrodinger_energy.png)
![sch_bench_err](/benchmarks/plots/schrodinger.png)

### Timing relative to `pyriccaticpp` for the Schrodinger equation for relative tolerance 1e-6

|quantum_number |BDF    |DOP853 |RK45   |
|:--------------|:------|:------|:------|
|50             |18.94  |**1.660**  |4.940  |
|100            |26.34  |**2.260**  |7.024  |
|1000           |78.51  |**6.708**  |21.901 |
|10000          |237.36 |**20.145** |66.802 |

Each value can be interpreted as "in the Schrodinger benchmark, pyriccaticpp is `x` times faster than {method}."

### Relative error results

The figure below (`schrodinger_err.png`) shows the relative error in the computed energy level compared to the reference values in @banerjee1978anharmonic. All methods achieve an error within roughly an order of magnitude of the local tolerance, with the higher-order methods (`DOP853` and `pyriccaticpp`) performing better.

![sch_bench_err](/benchmarks/plots/schrodinger_err.png)

## Summary

Overall, `pyriccaticpp` offers substantial speed-up and robust accuracy for problems that exhibit oscillatory behavior, and is competitive with the methods offered by `scipy.integrate.solve_ivp` otherwise, particularly in the case of stiff equations and when high accuracy is required.


## System Info

All tests we run on a system with the following hardware

```
=== Operating System ===
PRETTY_NAME: Rocky Linux 8.10 (Green Obsidian)

=== Kernel ===
Kernel: Linux 4.18.0-553.51.1.el8_10.x86_64

=== Compiler ===
gcc-12.2.0

=== Python ===

Python 3.11.11

=== CPU ===
Architecture: x86_64
CPU op-mode(s):, 32-bit,
Byte Little
Threads/core: 2
Cores/socket: 8
Socket(s): 2
Model: name: Intel(R) Xeon(R) Gold 6234 CPU @ 3.30GHz
Base MHz: 3300.000
Max MHz: 4000.0000
Min MHz: 1200.0000
Virtualization:: VT-x
L1d cache: 32K
L1i cache: 32K
L2 cache: 1024K
L3 cache: 25344K

```
